{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://tracy/./src/utils/storage.ts","webpack://tracy/webpack/bootstrap","webpack://tracy/webpack/runtime/define property getters","webpack://tracy/webpack/runtime/hasOwnProperty shorthand","webpack://tracy/webpack/runtime/make namespace object","webpack://tracy/./src/background/background.ts"],"sourcesContent":["export const setTabStates = (tabsInfoData) => {\n    // let existingState: TabInfo[][] = [];\n    // getTabStates().then((tabsArray) => {\n    //   existingState = tabsArray;\n    // });\n    // if (existingState.length !== 0) {\n    //   existingState.push(tabsInfoData);\n    // }\n    const vals = {\n        tabStates: tabsInfoData,\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => resolve());\n        // chrome.runtime.sendMessage({ action: \"update\" });\n    });\n};\nexport const getTabStates = () => {\n    const keys = [\"tabStates\"];\n    return new Promise((resolve) => {\n        chrome.storage.local.get(keys, (res) => {\n            var _a;\n            resolve((_a = res.tabStates) !== null && _a !== void 0 ? _a : []);\n        });\n    });\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { setTabStates } from \"../utils/storage\";\nlet existingTabId = null;\nchrome.runtime.onInstalled.addListener((event) => {\n    setTabStates([]);\n});\nchrome.action.onClicked.addListener(function (tab) {\n    if (existingTabId) {\n        chrome.tabs.get(existingTabId, function (tab) {\n            if (chrome.runtime.lastError) {\n                chrome.tabs.create({ url: \"popup.html\" }, function (newTab) {\n                    existingTabId = newTab.id;\n                });\n            }\n            else {\n                // If the tab is already open, switch to it\n                chrome.tabs.update(existingTabId, { active: true });\n            }\n        });\n    }\n    else {\n        // If the tab is not open, create a new one\n        chrome.tabs.create({ url: \"popup.html\" }, function (newTab) {\n            existingTabId = newTab.id;\n        });\n    }\n});\nlet tabInfo = [];\nlet globalTabState = [];\nlet tabSyncState = [];\nlet tabIdList = [];\nlet childTabIdList = [];\nlet removedTabIdList = [];\nlet allTabStates = [];\n// const getAllTabsInfo = () => {\n//   chrome.tabs.query({}, function (tabs: chrome.tabs.Tab[]) {\n//     const tabsArr: OriginalTabInfo[] = [];\n//     tabs.forEach((tab) => {\n//       tabsArr.push({\n//         id: tab.id,\n//         index: tab.index,\n//         url: tab.url,\n//         title: tab.title,\n//       });\n//     });\n//     originalTabsInfo.tabsData = tabsArr;\n//   });\n// };\n// adding all the opened tabs for the first time\nchrome.tabs.query({}, function (tabs) {\n    tabs.forEach((tab) => {\n        tabIdList.push(tab.id);\n        tabInfo.push({\n            type: \"existing\",\n            id: tab.id,\n            index: tab.index,\n            url: tab.url,\n            title: tab.title,\n            childId: [],\n            changeLog: { url: [], title: [], id: [] },\n        });\n        allTabStates.push({\n            urls: [tab.url],\n            titles: [tab.title],\n            type: \"existing\",\n            tabId: tab.id,\n        });\n    });\n    globalTabState = tabInfo;\n    setTabStates(globalTabState);\n    console.log({ allTabStates });\n    console.log({ tabInfo });\n    // console.log({ tabIdList });\n    // console.log({ updatedTabIdList });\n    // console.log({ childTabIdList });\n    // console.log({ removedTabIdList });\n    // console.log({ replacedTabIdList });\n});\nconst syncTabsfromInfo = () => {\n    tabInfo.forEach((tab) => {\n        const ind = allTabStates.findIndex((tabS) => tabS.tabId === tab.id);\n        if (ind !== -1) {\n            if (tab.type === \"removed\") {\n                //do something\n                allTabStates[ind].type = \"removed\";\n            }\n            else if (tab.url !== allTabStates[ind].urls.at(-1)) {\n                allTabStates[ind].urls.push(tab.url);\n            }\n            else if (tab.title !== allTabStates[ind].titles.at(-1)) {\n                allTabStates[ind].titles.push(tab.title);\n            }\n        }\n        else {\n            allTabStates.push({\n                urls: [tab.url],\n                titles: [tab.title],\n                type: tab.type,\n                tabId: tab.id,\n            });\n        }\n    });\n};\n// tracking when a new tab is created\nchrome.tabs.onCreated.addListener((newTab) => {\n    tabIdList.push(newTab.id);\n    tabInfo.push({\n        type: \"created\",\n        id: newTab.id,\n        index: newTab.index,\n        childId: [],\n        changeLog: { url: [], title: [], id: [] },\n    });\n    if (newTab.openerTabId) {\n        childTabIdList.push(newTab.id);\n        const ind = tabInfo.findIndex((tab) => tab.id === newTab.openerTabId);\n        tabInfo[ind].childId.push(newTab.id);\n        tabInfo[ind].type = \"child added\";\n    }\n    globalTabState = tabInfo;\n    setTabStates(globalTabState);\n    // syncTabsfromInfo();\n    // console.log({ allTabStates });\n    // console.log({ tabInfo });\n    // console.log({ tabIdList });\n    // console.log({ updatedTabIdList });\n    // console.log({ childTabIdList });\n    // console.log({ removedTabIdList });\n    // console.log({ replacedTabIdList });\n});\n//tracking when a tab is deleted\nchrome.tabs.onRemoved.addListener((tabId) => {\n    removedTabIdList.push(tabId);\n    const ind = tabInfo.findIndex((tab) => tab.id === tabId);\n    tabInfo[ind].type = \"removed\";\n    globalTabState = tabInfo;\n    setTabStates(globalTabState);\n    syncTabsfromInfo();\n    console.log({ allTabStates });\n    // console.log({ tabInfo });\n    // console.log({ tabIdList });\n    // console.log({ updatedTabIdList });\n    // console.log({ childTabIdList });\n    // console.log({ removedTabIdList });\n    // console.log({ replacedTabIdList });\n});\n// tracking all the tab updates\nchrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {\n    // console.log({ changeInfo });\n    var _a, _b, _c;\n    const ind = tabInfo.findIndex((tab) => tab.id === tabId);\n    if (ind !== -1) {\n        if (tabInfo[ind].changeLog) {\n            tabInfo[ind].type = \"updated\";\n        }\n        (_a = tabInfo[ind].changeLog.id) === null || _a === void 0 ? void 0 : _a.push(tabId);\n        if (changeInfo.url) {\n            (_b = tabInfo[ind].changeLog.url) === null || _b === void 0 ? void 0 : _b.push(changeInfo.url);\n        }\n        if (changeInfo.title) {\n            (_c = tabInfo[ind].changeLog.title) === null || _c === void 0 ? void 0 : _c.push(changeInfo.title);\n        }\n    }\n    syncTabInfo(tabId);\n    syncTabsfromInfo();\n    console.log({ allTabStates });\n    // console.log({ tabInfo });\n    // console.log({ tabIdList });\n    // console.log({ updatedTabIdList });\n    // console.log({ childTabIdList });\n    // console.log({ removedTabIdList });\n    // console.log({ replacedTabIdList });\n});\nconst syncTabInfo = (id) => {\n    const ind = tabInfo.findIndex((tab) => tab.id === id);\n    if (ind !== -1) {\n        if (tabInfo[ind].changeLog.url.length !== 0) {\n            tabInfo[ind].url = tabInfo[ind].changeLog.url.at(-1);\n        }\n        if (tabInfo[ind].changeLog.title.length !== 0) {\n            tabInfo[ind].title = tabInfo[ind].changeLog.title.at(-1);\n        }\n    }\n    globalTabState = tabInfo;\n    setTabStates(globalTabState);\n};\n"],"names":[],"sourceRoot":""}