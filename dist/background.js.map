{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://tracy/./src/utils/storage.ts","webpack://tracy/webpack/bootstrap","webpack://tracy/webpack/runtime/define property getters","webpack://tracy/webpack/runtime/hasOwnProperty shorthand","webpack://tracy/webpack/runtime/make namespace object","webpack://tracy/./src/background/background.ts"],"sourcesContent":["// export const setTabStates = (tabsInfoData: TabInfo[]): Promise<void> => {\n//   // let existingState: TabInfo[][] = [];\n//   // getTabStates().then((tabsArray) => {\n//   //   existingState = tabsArray;\n//   // });\n//   // if (existingState.length !== 0) {\n//   //   existingState.push(tabsInfoData);\n//   // }\n//   const vals: LocalTabState = {\n//     tabStates: tabsInfoData,\n//   };\n//   return new Promise((resolve) => {\n//     chrome.storage.local.set(vals, () => resolve());\n//     // chrome.runtime.sendMessage({ action: \"update\" });\n//   });\n// };\nexport const setTabStates = (tabsInfoData) => {\n    // let existingState: TabInfo[][] = [];\n    // getTabStates().then((tabsArray) => {\n    //   existingState = tabsArray;\n    // });\n    // if (existingState.length !== 0) {\n    //   existingState.push(tabsInfoData);\n    // }\n    const vals = {\n        tabStates: tabsInfoData,\n    };\n    return new Promise((resolve) => {\n        chrome.storage.local.set(vals, () => resolve());\n        // chrome.runtime.sendMessage({ action: \"update\" });\n    });\n};\n// export const getTabStates = (): Promise<TabInfo[]> => {\n//   const keys: LocalTabSatteKeys[] = [\"tabStates\"];\n//   return new Promise((resolve) => {\n//     chrome.storage.local.get(keys, (res: LocalTabState) => {\n//       resolve(res.tabStates ?? []);\n//     });\n//   });\n// };\nexport const getTabStates = () => {\n    const keys = [\"tabStates\"];\n    return new Promise((resolve) => {\n        chrome.storage.local.get(keys, (res) => {\n            var _a;\n            resolve((_a = res.tabStates) !== null && _a !== void 0 ? _a : []);\n        });\n    });\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { setTabStates } from \"../utils/storage\";\nlet existingTabId = null;\nchrome.runtime.onInstalled.addListener((event) => {\n    setTabStates([]);\n});\nchrome.action.onClicked.addListener(function (tab) {\n    if (existingTabId) {\n        chrome.tabs.get(existingTabId, function (tab) {\n            if (chrome.runtime.lastError) {\n                chrome.tabs.create({ url: \"popup.html\" }, function (newTab) {\n                    existingTabId = newTab.id;\n                });\n            }\n            else {\n                // If the tab is already open, switch to it\n                chrome.tabs.update(existingTabId, { active: true });\n            }\n        });\n    }\n    else {\n        // If the tab is not open, create a new one\n        chrome.tabs.create({ url: \"popup.html\" }, function (newTab) {\n            existingTabId = newTab.id;\n        });\n    }\n});\nlet tabInfo = [];\n// let globalTabState: TabInfo[] = [];\nlet globalTabState = [];\nlet tabIdList = [];\nlet childTabIdList = [];\nlet removedTabIdList = [];\nlet historyStates = [];\nlet globalIndex = 0;\nconst syncStatesFirstTime = () => {\n    tabInfo.forEach((tab) => {\n        const nodeData = {\n            type: tab.type,\n            url: tab.url,\n            hasPrevious: false,\n            hasChild: false,\n            title: tab.title,\n            id: tab.id,\n            globalIndex: tab.globalIndex,\n        };\n        const nodeInfo = [nodeData];\n        historyStates.push({\n            node: nodeInfo,\n        });\n    });\n};\nfunction findParentArrayAndUpdate(tree, gindex, newNode, ind) {\n    function traverse(nodes, parentPath) {\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.globalIndex === gindex) {\n                if (node.url === newNode.url) {\n                    return;\n                }\n                globalIndex += 1;\n                tabInfo[ind].globalIndex = globalIndex;\n                newNode.globalIndex = globalIndex;\n                // Found the target node, update its parent's node array with the new node\n                const parent = parentPath[parentPath.length - 1];\n                parent.node.push(newNode);\n                return;\n            }\n            if (node.hasChild && node.child) {\n                for (const cnode of node.child) {\n                    traverse(cnode.node, [...parentPath, cnode]);\n                }\n                // traverse(node.child, [...parentPath, { node }]); // Add the current node to the path\n            }\n        }\n    }\n    for (const treeNode of tree) {\n        traverse(treeNode.node, [treeNode]);\n    }\n}\nfunction traverseAndUpdateByGlobalIndex(tree, gindex, updateFn) {\n    let nodeFound = false;\n    function traverse(nodes) {\n        for (const node of nodes) {\n            if (node.globalIndex === gindex) {\n                // Update the properties using the provided update function\n                updateFn(node);\n                nodeFound = true;\n                return;\n            }\n            if (node.hasChild && node.child) {\n                for (const Cnode of node.child)\n                    traverse(Cnode.node);\n            }\n        }\n    }\n    for (const treeNode of tree) {\n        traverse(treeNode.node);\n    }\n    return nodeFound;\n}\n// adding all the opened tabs for the first time\nchrome.tabs.query({}, function (tabs) {\n    tabs.forEach((tab) => {\n        tabIdList.push(tab.id);\n        globalIndex += 1;\n        tabInfo.push({\n            type: \"existing\",\n            id: tab.id,\n            index: tab.index,\n            url: tab.url,\n            title: tab.title,\n            childId: [],\n            changeLog: { url: [], title: [], id: [] },\n            hasOpenerId: false,\n            globalIndex: globalIndex,\n        });\n    });\n    // globalTabState = tabInfo;\n    globalTabState = historyStates;\n    syncStatesFirstTime();\n    setTabStates(globalTabState);\n    // console.log({ tabInfo });\n    // console.log({ historyStates });\n    // console.log({ tabIdList });\n    // console.log({ updatedTabIdList });\n    // console.log({ childTabIdList });\n    // console.log({ removedTabIdList });\n    // console.log({ replacedTabIdList });\n});\n// tracking when a new tab is created\nchrome.tabs.onCreated.addListener((newTab) => {\n    tabIdList.push(newTab.id);\n    globalIndex += 1;\n    tabInfo.push({\n        type: \"created\",\n        id: newTab.id,\n        title: newTab.title,\n        index: newTab.index,\n        childId: [],\n        changeLog: { url: [], title: [], id: [] },\n        hasOpenerId: false,\n        globalIndex: globalIndex,\n    });\n    if (newTab.openerTabId) {\n        childTabIdList.push(newTab.id);\n        const ind = tabInfo.findIndex((tab) => tab.id === newTab.openerTabId);\n        tabInfo[ind].childId.push(newTab.id);\n        tabInfo[ind].type = \"child added\";\n        const cind = tabInfo.findIndex((tab) => tab.id === newTab.id);\n        tabInfo[cind].hasOpenerId = true;\n        tabInfo[cind].openerId = newTab.openerTabId;\n    }\n    // globalTabState = tabInfo;\n    if (!newTab.openerTabId) {\n        const nodeData = {\n            type: \"created\",\n            url: newTab.url,\n            hasPrevious: false,\n            hasChild: false,\n            title: newTab.title,\n            id: newTab.id,\n            globalIndex: globalIndex,\n        };\n        const nodeInfo = [nodeData];\n        historyStates.push({\n            node: nodeInfo,\n        });\n    }\n    else {\n        const gindex = tabInfo.findIndex((tab) => tab.id === newTab.openerTabId);\n        const newTabGindex = tabInfo[gindex].globalIndex;\n        traverseAndUpdateByGlobalIndex(historyStates, newTabGindex, (node) => {\n            if (!node.hasChild) {\n                const nodeData = {\n                    type: \"created\",\n                    url: newTab.url,\n                    hasPrevious: false,\n                    hasChild: false,\n                    title: newTab.title,\n                    id: newTab.id,\n                    globalIndex: globalIndex,\n                    isFirstChild: true\n                };\n                node.child = [\n                    {\n                        node: [nodeData],\n                    },\n                ];\n                node.hasChild = true;\n                node.type = \"updated\";\n            }\n            else {\n                const nodeData = {\n                    type: \"created\",\n                    url: newTab.url,\n                    hasPrevious: true,\n                    hasChild: false,\n                    title: newTab.title,\n                    id: newTab.id,\n                    globalIndex: globalIndex,\n                };\n                node.child.push({\n                    node: [nodeData],\n                });\n                node.type = \"updated\";\n            }\n        });\n    }\n    globalTabState = historyStates;\n    setTabStates(globalTabState);\n    // console.log({ tabInfo });\n    // console.log({ historyStates });\n});\n//tracking when a tab is deleted\nchrome.tabs.onRemoved.addListener((tabId) => {\n    removedTabIdList.push(tabId);\n    const ind = tabInfo.findIndex((tab) => tab.id === tabId);\n    tabInfo[ind].type = \"removed\";\n    // globalTabState = tabInfo;\n    const gindex = tabInfo[ind].globalIndex;\n    traverseAndUpdateByGlobalIndex(historyStates, gindex, (node) => {\n        node.type = \"removed\";\n    });\n    globalTabState = historyStates;\n    setTabStates(globalTabState);\n    // console.log({ tabInfo });\n    // console.log({ historyStates });\n});\n// tracking all the tab updates\nchrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {\n    // console.log({ changeInfo });\n    //\n    // console.log(tab.status);\n    // console.log(tab.active);\n    var _a, _b, _c, _d, _e, _f;\n    const ind = tabInfo.findIndex((tab) => tab.id === tabId);\n    if (ind !== -1) {\n        if (tabInfo[ind].type === \"created\") {\n            (_a = tabInfo[ind].changeLog.id) === null || _a === void 0 ? void 0 : _a.push(tabId);\n            if (changeInfo.url) {\n                (_b = tabInfo[ind].changeLog.url) === null || _b === void 0 ? void 0 : _b.push(changeInfo.url);\n            }\n            if (changeInfo.title) {\n                (_c = tabInfo[ind].changeLog.title) === null || _c === void 0 ? void 0 : _c.push(changeInfo.title);\n            }\n            syncTabInfo(tabId);\n            if (tab.status === \"complete\") {\n                tabInfo[ind].type = \"updated\";\n            }\n            // if (tabInfo[ind].changeLog) {\n            //   tabInfo[ind].type = \"updated\";\n            // }\n        }\n        else if (tabInfo[ind].type !== \"removed\") {\n            (_d = tabInfo[ind].changeLog.id) === null || _d === void 0 ? void 0 : _d.push(tabId);\n            if (changeInfo.url) {\n                (_e = tabInfo[ind].changeLog.url) === null || _e === void 0 ? void 0 : _e.push(changeInfo.url);\n            }\n            if (changeInfo.title) {\n                (_f = tabInfo[ind].changeLog.title) === null || _f === void 0 ? void 0 : _f.push(changeInfo.title);\n            }\n            updateTabInfo(tabId);\n            if (tab.status === \"complete\") {\n                tabInfo[ind].type = \"updated\";\n                const gindex = tabInfo[ind].globalIndex;\n                const nodeData = {\n                    type: \"updated\",\n                    url: tabInfo[ind].url,\n                    hasPrevious: true,\n                    hasChild: false,\n                    title: tabInfo[ind].title,\n                    id: tabInfo[ind].id,\n                    globalIndex: gindex,\n                };\n                findParentArrayAndUpdate(historyStates, gindex, nodeData, ind);\n            }\n        }\n    }\n    // globalTabState = tabInfo;\n    globalTabState = historyStates;\n    setTabStates(globalTabState);\n    // console.log({ tabInfo });\n    // console.log({ historyStates });\n});\nconst syncTabInfo = (id) => {\n    const ind = tabInfo.findIndex((tab) => tab.id === id);\n    const gindex = tabInfo[ind].globalIndex;\n    if (ind !== -1) {\n        if (tabInfo[ind].changeLog.url.length !== 0) {\n            tabInfo[ind].url = tabInfo[ind].changeLog.url.at(-1);\n            traverseAndUpdateByGlobalIndex(historyStates, gindex, (node) => {\n                node.url = tabInfo[ind].url;\n                node.type = \"updated\";\n            });\n        }\n        if (tabInfo[ind].changeLog.title.length !== 0) {\n            tabInfo[ind].title = tabInfo[ind].changeLog.title.at(-1);\n            traverseAndUpdateByGlobalIndex(historyStates, gindex, (node) => {\n                node.title = tabInfo[ind].title;\n            });\n        }\n    }\n};\nconst updateTabInfo = (id) => {\n    const ind = tabInfo.findIndex((tab) => tab.id === id);\n    const gindex = tabInfo[ind].globalIndex;\n    if (ind !== -1) {\n        if (tabInfo[ind].changeLog.url.length !== 0) {\n            tabInfo[ind].url = tabInfo[ind].changeLog.url.at(-1);\n        }\n        if (tabInfo[ind].changeLog.title.length !== 0) {\n            tabInfo[ind].title = tabInfo[ind].changeLog.title.at(-1);\n        }\n    }\n};\n"],"names":[],"sourceRoot":""}